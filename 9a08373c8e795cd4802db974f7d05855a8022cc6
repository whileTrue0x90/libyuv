{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "468a19df_c12f5ae6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1208520
      },
      "writtenOn": "2022-05-24T18:15:59Z",
      "side": 1,
      "message": "is there anything i need to do to fix the LUCI CQ error?",
      "revId": "9a08373c8e795cd4802db974f7d05855a8022cc6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a3dbadb5_a12f7622",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-05-24T18:21:26Z",
      "side": 1,
      "message": "A profile on Pixel 4\n64.76%,  InterpolateRow_16To8_C\n25.52%,  Convert16To8Row_NEON\n\nshows the C code is a bottleneck.\nCompared to other conversions it is in the middle\nI210ToI410_Opt (590 ms)\nI210ToI010_Opt (272 ms)\nI210ToI420_Opt (365 ms)  \u003c-- new function\nI210ToI422_Opt (227 ms)\n\nBut it should be faster than I210ToI422.\nIf assembly is not written, it would be better to refactor the function to use I210ToI422 internally to convert a row at a time to a temporary buffer (using NEON) and then merge 2 rows of I422 to make I420, also with NEON/AVX.\n\nIf NEON is written but not AVX2, the code can also do both - have a 1 step conversion for NEON and 2 step for AVX2.  Typically 2 steps works better for Intel than ARM.\n\nWe can still go ahead with this CL as is, establishing the API and aim to improve performance in a follow up\n",
      "revId": "9a08373c8e795cd4802db974f7d05855a8022cc6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3ba64b78_2c1ac671",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-05-24T18:48:48Z",
      "side": 1,
      "message": "The unittests are not catching a bug as they expect to compare NEON to C.\nAnother type of test you could do is \u0027transitive\u0027 where you do a 2 step conversion vs the new function and compare the results.\n",
      "revId": "9a08373c8e795cd4802db974f7d05855a8022cc6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "548b532f_6e26a371",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 6
      },
      "lineNbr": 0,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-05-24T22:14:25Z",
      "side": 1,
      "message": "mirko\u0027s LGTM will allow me to submit, but there are bugs, mainly with clamp255 usage.\n\nA thought on simple optimization.  HalfRow_NEON would allow the C code a way call a specialized version for 50/50.  And there is already a 100% version that can be used.  Would want HalfRow_NEON HalfRow_16_NEON and HalfRow_16To8_NEON for completeness.",
      "revId": "9a08373c8e795cd4802db974f7d05855a8022cc6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b5477e8d_22c6145c",
        "filename": "source/row_common.cc",
        "patchSetId": 6
      },
      "lineNbr": 3414,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-05-26T07:04:04Z",
      "side": 1,
      "message": "clamp the final result after the shift is done.",
      "range": {
        "startLine": 3414,
        "startChar": 0,
        "endLine": 3414,
        "endChar": 11
      },
      "revId": "9a08373c8e795cd4802db974f7d05855a8022cc6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6d875ce5_d86145ef",
        "filename": "source/row_common.cc",
        "patchSetId": 6
      },
      "lineNbr": 3478,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-05-26T07:04:04Z",
      "side": 1,
      "message": "clamp the final result after the shift is done.",
      "range": {
        "startLine": 3478,
        "startChar": 0,
        "endLine": 3478,
        "endChar": 26
      },
      "revId": "9a08373c8e795cd4802db974f7d05855a8022cc6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a44d38ce_4c1d95ef",
        "filename": "source/row_common.cc",
        "patchSetId": 6
      },
      "lineNbr": 3482,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-05-26T07:04:04Z",
      "side": 1,
      "message": "clamp the final result after the shift is done.",
      "range": {
        "startLine": 3482,
        "startChar": 0,
        "endLine": 3482,
        "endChar": 26
      },
      "revId": "9a08373c8e795cd4802db974f7d05855a8022cc6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "58e3b94c_f5b32210",
        "filename": "source/row_common.cc",
        "patchSetId": 6
      },
      "lineNbr": 3489,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-05-26T07:04:04Z",
      "side": 1,
      "message": "add scale and clamp, same as main loop",
      "range": {
        "startLine": 3489,
        "startChar": 0,
        "endLine": 3489,
        "endChar": 77
      },
      "revId": "9a08373c8e795cd4802db974f7d05855a8022cc6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1398f611_736f378b",
        "filename": "source/scale_common.cc",
        "patchSetId": 6
      },
      "lineNbr": 1618,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-05-25T12:30:54Z",
      "side": 1,
      "message": "note that if we keep 16To8 functions\n1. scale can be done more efficiently on NEON by taking bits (10) and doing a shift.\n2. 16 bit functions require 32 bit math, but if you know the values are in the lsb, the math can be 16 bit, so doing a \u002712\u0027 bit version will be nearly 2x faster.\nBut it increases the number of functions.  It may be better to focus on the conversion itself - I210ToI420, implementing the necessary row function in NEON/AVX2/C\n\nAll functions should be implemented in AVX2/NEON.  If this can\u0027t be optimized, an alternative should be found.  It appears feasible, but opens a can of worms.\nI410ToI420 would want general purpose scaling with 10 to 8.\nP010 will want conversion and scaling, which is a 2 channel UV with 16 bits but in the msb.  The \u0027scale\u0027 parameter may not work",
      "range": {
        "startLine": 1618,
        "startChar": 0,
        "endLine": 1618,
        "endChar": 40
      },
      "revId": "9a08373c8e795cd4802db974f7d05855a8022cc6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6b64dee9_c0fe5a8f",
        "filename": "source/scale_common.cc",
        "patchSetId": 6
      },
      "lineNbr": 1621,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-05-24T19:07:57Z",
      "side": 1,
      "message": "this should be removed... flipping is for public functions, not internal.\n\nit should not use int64 if possible, for efficiency on aarch32/x86 builds.\n\nvariables also need to be declared first for C89 compatability.\n\nBut just remove the inverting from here.  I210ToI420 function can do it.",
      "revId": "9a08373c8e795cd4802db974f7d05855a8022cc6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1a61edcb_6fc801c7",
        "filename": "source/scale_common.cc",
        "patchSetId": 6
      },
      "lineNbr": 1621,
      "author": {
        "id": 1208520
      },
      "writtenOn": "2022-05-25T08:52:20Z",
      "side": 1,
      "message": "The issue is that there is not public planar function, so if done in the I210toI420 method, it will require to do it per plane, which is kind of awfull.\n\nI have added ScalePlane_16To8 to wrap the call to this, but it requires some other functions which I am not sure how likely are going to be accepted.",
      "parentUuid": "6b64dee9_c0fe5a8f",
      "revId": "9a08373c8e795cd4802db974f7d05855a8022cc6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "555009ad_e459fb09",
        "filename": "source/scale_common.cc",
        "patchSetId": 6
      },
      "lineNbr": 1621,
      "author": {
        "id": 1115898
      },
      "writtenOn": "2022-05-25T12:30:54Z",
      "side": 1,
      "message": "Ack.  But the other ScalePlaneVertical functions dont do it, and its not efficient doing int64_t math on 32 bit cpus.  A different type should be added.  All functions that do stride * height should have their math checked.\nOnly public functions support the negative height.  The ScalePlane functions.\nIts not important to the functionality of ScalePlaneVertical at the moment, and for I210ToI420, we likely want to bypass scale functions and directly blend 2 rows in a row function.",
      "parentUuid": "1a61edcb_6fc801c7",
      "revId": "9a08373c8e795cd4802db974f7d05855a8022cc6",
      "serverId": "3ce6091f-6c88-37e8-8c75-72f92ae8dfba"
    }
  ]
}